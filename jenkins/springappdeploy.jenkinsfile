pipeline {
    agent any

    parameters {
        string(name: 'GITHUB_REPO', defaultValue: 'SIDHARTH27163/ERP_SPRINGBOOT_APIs', description: 'GitHub Repository Name')
        choice(name: 'BRANCH', choices: ['main', 'dev', 'feature'], description: 'Select the branch to checkout')
    }

    environment {
        IMAGE_NAME = "springboot-container"
        DOCKER_REGISTRY = "localhost:5000"
        DEPLOYMENT_NAME = "springboot-app"
    }

    stages {
        stage('Clean Workspace') {
            steps {
                echo "Cleaning workspace..."
                cleanWs()
            }
        }

        stage('Clone Repo') {
            steps {
                bat """
                git clone -b ${params.BRANCH} https://github.com/${params.GITHUB_REPO}.git erp-backend
                """
            }
        }

        stage('Build with Maven') {
            steps {
                bat """
                cd erp-backend
                mvn clean install -DskipTests
                """
            }
        }

        stage('Build & Tag Docker Image') {
            steps {
                script {
                    env.VERSION = "1.0.${env.BUILD_NUMBER}"
                    env.BACKUP_VERSION = "1.0.${env.BUILD_NUMBER.toInteger() - 1}"
                }

                bat """
                set IMAGE_NAME=${IMAGE_NAME}
                set VERSION=${VERSION}
                set DOCKER_REGISTRY=${DOCKER_REGISTRY}

                cd erp-backend
                docker build -t %IMAGE_NAME%:%VERSION% .
                docker tag %IMAGE_NAME%:%VERSION% %DOCKER_REGISTRY%/%IMAGE_NAME%:%VERSION%
                """
            }
        }

        // Uncomment if pushing to registry is needed
        // stage('Push Docker Image') {
        //     steps {
        //         bat """
        //         docker push ${DOCKER_REGISTRY}/${IMAGE_NAME}:${VERSION}
        //         """
        //     }
        // }

        stage('Deploy to Kubernetes') {
            steps {
                withCredentials([file(credentialsId: 'kubeconfig-dev', variable: 'KUBECONFIG')]) {
                    powershell """
                    \$env:VERSION = '${VERSION}'

                    cd erp-backend

                    (Get-Content springboot-deployment.yaml) -replace '__VERSION__', \$env:VERSION | Set-Content temp-deployment.yaml

                    kubectl apply -f temp-deployment.yaml
                    kubectl apply -f springboot-service.yaml
                    """
                }
            }
        }

        stage('Health Check') {
            steps {
                script {
                    def status = bat(script: "kubectl rollout status deployment/${DEPLOYMENT_NAME}", returnStatus: true)
                    if (status != 0) {
                        currentBuild.result = 'FAILURE'
                        error("Deployment failed!")
                    }
                }
            }
        }

        stage('Post-Deployment Cleanup') {
            steps {
                bat """
                docker image prune -f
                docker rmi -f ${IMAGE_NAME}:${BACKUP_VERSION} || echo "No old image found"
                """
            }
        }
    }

    post {
        success {
            echo "Deployment succeeded. Cleaning up old deployments..."
            bat """
            kubectl delete deployment ${DEPLOYMENT_NAME}-backup --ignore-not-found=true
            """
        }

        failure {
            echo "Deployment failed! Rolling back to previous stable version..."

            powershell """
            \$env:IMAGE_NAME = '${IMAGE_NAME}'
            \$env:DOCKER_REGISTRY = '${DOCKER_REGISTRY}'
            \$env:BACKUP_VERSION = '${BACKUP_VERSION}'

            kubectl delete deployment ${DEPLOYMENT_NAME} --ignore-not-found=true

            (Get-Content erp-backend/springboot-deployment.yaml) -replace 'image: .*', 'image: \$env:DOCKER_REGISTRY/\$env:IMAGE_NAME:\$env:BACKUP_VERSION' | Set-Content rollback.yaml

            kubectl apply -f rollback.yaml

            kubectl patch deployment ${DEPLOYMENT_NAME} -p '{"metadata":{"name":"${DEPLOYMENT_NAME}-backup"}}'
            """
        }
    }
}
